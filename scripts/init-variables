#!/bin/bash -e

CDIR=$(dirname "${BASH_SOURCE}")

set -x

echo $AWS_REGION
echo $COREOS_CHANNEL
echo $COREOS_VM_TYPE
echo $AWS_EC2_KEY_NAME
echo $INTERNAL_TLD
echo $CLUSTER_NAME
CIDR_ALLOW_SSH=`$CDIR/myip`
echo $CIDR_VPC
echo $CIDR_PODS
echo $CIDR_SERVICE_CLUSTER
echo $K8S_SERVICE_IP
echo $K8S_DNS_IP
echo $ETCD_IPS
echo $HYPERKUBE_IMAGE
echo $HYPERKUBE_TAG
echo $PKI_IP

set +x

COREOS_AMI_ID=`curl -s \
  $(printf "http://%s.release.core-os.net/amd64-usr/current/coreos_production_ami_%s_%s.txt" \
    $COREOS_CHANNEL $COREOS_VM_TYPE $AWS_REGION)`

AWS_ACCOUNT_ID=`aws iam get-user --output json \
	| awk '/arn:aws:/{print $2}' \
	| grep -Eo '[[:digit:]]{12}'`

AWS_REGION_AZS=`aws ec2 describe-availability-zones --region ${AWS_REGION} --output json \
  | jq --raw-output '.AvailabilityZones | map(.ZoneName) | .[]' \
  | xargs \
  | sed -e 's/ /,/g'`


cat <<EOF > terraform.tfvars
# Generated by scripts/init-variables.sh
aws = {
  account-id = "${AWS_ACCOUNT_ID}"
  azs = "${AWS_REGION_AZS}"
  key-name = "${AWS_EC2_KEY_NAME}"
  region = "${AWS_REGION}"
}
cidr = {
  allow-ssh = "${CIDR_ALLOW_SSH}"
  pods = "${CIDR_PODS}"
  service-cluster = "${CIDR_SERVICE_CLUSTER}"
  vpc = "${CIDR_VPC}"
}
coreos-aws = {
  ami = "${COREOS_AMI_ID}"
  channel = "${COREOS_CHANNEL}"
  type = "${COREOS_VM_TYPE}"
}
k8s = {
  hyperkube-image = "${HYPERKUBE_IMAGE}"
  hyperkube-tag = "${HYPERKUBE_TAG}"
}
dns-service-ip = "${K8S_DNS_IP}"
internal-tld = "${INTERNAL_TLD}"
k8s-service-ip = "${K8S_SERVICE_IP}"
name = "${CLUSTER_NAME}"
pki-ip = "${PKI_IP}"
s3-bucket = "${AWS_ACCOUNT_ID}-${CLUSTER_NAME}-${AWS_REGION}"
etcd-ips = "$ETCD_IPS"
EOF

if [ -f ./vpc-existing.tfvars ]; then cat ./vpc-existing.tfvars >>terraform.tfvars ; fi
cat terraform.tfvars
